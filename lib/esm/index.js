function _slicedToArray(arr,i){return _arrayWithHoles(arr)||_iterableToArrayLimit(arr,i)||_nonIterableRest();}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance");}function _iterableToArrayLimit(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"]!=null)_i["return"]();}finally{if(_d)throw _e;}}return _arr;}function _arrayWithHoles(arr){if(Array.isArray(arr))return arr;}import{useState,useEffect}from"react";import serialize from"serialize-javascript";const evtTarget=new EventTarget();const deserialize=serializedJavascript=>eval("(".concat(serializedJavascript,")"));const useStorage=storage=>(key,defaultValue)=>{const raw=storage.getItem(key);const _useState=useState(raw?deserialize(raw):defaultValue),_useState2=_slicedToArray(_useState,2),value=_useState2[0],setValue=_useState2[1];const updater=updatedValue=>{setValue(updatedValue);storage.setItem(key,serialize(updatedValue));evtTarget.dispatchEvent(new CustomEvent("storage_change",{detail:{key}}));};defaultValue!=null&&!raw&&updater(defaultValue);useEffect(()=>{const listener=(_ref)=>{let detail=_ref.detail;if(detail.key===key){const lraw=storage.getItem(key);lraw!==raw&&setValue(deserialize(lraw));}};evtTarget.addEventListener("storage_change",listener);return()=>evtTarget.removeEventListener("storage_change",listener);});return[value,updater];};export const useLocalStorage=useStorage(localStorage);export const useSessionStorage=useStorage(sessionStorage);